<!DOCTYPE html>
<html>
<head>
    <title>PBS Mapping Tool v5.1 (Navigable)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .section {
            margin-bottom: 40px;
        }
        #matchesContainer {
            max-height: 465px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #outputContainer {
            white-space: pre-wrap;
            background-color: #000;
            color: #fff;
            padding: 10px;
        }
        .hidden {
            display: none;
        }
        .progress-bar {
            width: 100%;
            background-color: lightgray;
            height: 20px;
            margin-bottom: 10px;
        }
        .progress {
            height: 100%;
            background-color: blue;
            width: 0%;
        }
        .currentItemDetailsBox {
            background-color: lightgrey;
            color: black;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .disabled {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        
        /* --- LAYOUT FOR SPLIT VIEW --- */
        .mapping-row {
            display: flex;
            gap: 20px;
            align-items: flex-start; 
        }
        
        .mapping-left-col {
            flex: 1; /* Expands to fill space */
            min-width: 0; 
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between details and matches list */
        }

        /* Styles for the Auto-Match Log */
        #autoMatchLogContainer {
            /* Layout specific */
            width: 350px; 
            flex-shrink: 0; 
            display: none; /* Hidden by default, toggled by JS */
            
            /* Visuals */
            border: 1px solid #90cdf4;
            background-color: #ebf8ff;
            padding: 10px;
            border-radius: 5px;
            
            /* Height settings */
            display: flex;
            flex-direction: column;
        }
        
        #autoMatchLog {
            /* TALLER HEIGHT as requested */
            height: 750px; 
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            color: #2c5282;
            background-color: white; 
            border: 1px solid #bee3f8;
            padding: 5px;
            margin-top: 5px;
        }
        .log-entry {
            border-bottom: 1px solid #bee3f8;
            padding: 4px 0;
        }
        
        /* Styles for Settings Section */
        .settings-box {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 5px;
            background-color: #f9f9f9;
            max-width: 600px;
        }
        .setting-row {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            position: relative;
        }
        .setting-label {
            font-weight: bold;
            margin-right: 10px;
            min-width: 200px;
        }
        
        /* --- TOOLTIP STYLES --- */
        .tooltip-container {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }

        .info-icon {
            background-color: #e7f1ff;
            color: #0056b3;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            border: 1px solid #b3d7ff;
        }

        .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 10px;
            font-size: 0.85em;
            font-weight: normal;
            line-height: 1.4;
            position: absolute;
            z-index: 100;
            bottom: 135%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0px 4px 8px rgba(0,0,0,0.3);
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* --- NEW STYLES FOR EMBEDDED CODE EDITORS --- */
        .ccl-editor {
            width: 100%;
            height: 250px; 
            font-family: monospace;
            font-size: 12px;
            background-color: #f4f4f4;
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box; 
            white-space: pre;
            overflow: auto;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        
        /* Navigation Button Styles */
        .nav-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 8px 16px;
            cursor: pointer;
        }

        #backButton {
            background-color: #718096;
            color: white;
            border: none;
            border-radius: 4px;
        }
        
        #nextButton {
            background-color: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="pharmacyCatalogSection" class="section">
        <h2>Part 1: Pharmacy Catalog</h2>
        <p>
            <strong>Step 1:</strong> You can edit the CCL code you're about to copy to your clipboard directly below if you want.
        </p>
        
        <textarea id="pharmacyCatalogCCL" class="ccl-editor" placeholder="Paste the Pharmacy Catalog CCL extract code here...">
SELECT
    MAP_SYNONYM_ID_ = O.SYNONYM_ID
    , PRIMARY = UAR_GET_CODE_DISPLAY(O.CATALOG_CD)
    , NAME = O.MNEMONIC
    , ITEM_TYPE = EVALUATE
        (
            O.MNEMONIC_TYPE_CD
            , 2583.00,          "PRIMARY"
            , 2580.00,          "BRAND"
            , 614548.00,        "GENERIC"
            , 614544.00,        "GENERIC"
            , 614549.00,        "TRADE"
            , 614545.00,        "TRADE"
        )
FROM
    ORDER_CATALOG_SYNONYM   O
WHERE
    O.ACTIVE_IND = 1
    AND O.CATALOG_TYPE_CD = 2516 ; PHARMACY
WITH NOCOUNTER, SEPARATOR=" ", FORMAT, time = 10
</textarea>

        <p>
            <strong>Step 2:</strong> Click the button to copy the code above, run it in DVDev, and copy the output.
        </p>
        <button id="copyPharmacyCodeBtn">
            Copy Pharmacy Catalog CCL Extract Code
        </button>

        <p>
            <strong>Step 3:</strong> Click the button below to load the data from your clipboard.
        </p>
        <button id="loadPharmacyClipboardBtn" class="hidden">
            Copy Pharmacy Catalog from clipboard
        </button>
        <p id="pharmacyStatus"></p>
    </div>

    <div id="pbsItemsSection" class="section hidden">
        <h2>Part 2: PBS Items to Map</h2>
        <p>
            <strong>Step 1:</strong> You can edit the CCL code you're about to copy to your clipboard directly below if you want.
        </p>

        <textarea id="pbsItemsCCL" class="ccl-editor" placeholder="Paste the PBS Items to Map CCL extract code here...">
SELECT DISTINCT
; This will give you all the PBS items that:
; 1) are from the most recent package
; 2) do not have any mappings
; 3) are of presciber types that should be mapped
; 4) are of hospital types that should be mapped
; 5) This will not include Codes from the same package that should
;    have the exact same mappings. It is designed with the intention that the
;    user uses the auto mapping tool after mapping what this code brings back.
    MAP_PBS_DRUG_ID_ = P_D.PBS_DRUG_ID
    ; , DOMAIN = CURDOMAIN
    , PBS_CODE = P_L.PBS_ITEM_CODE
    ; , PRIMARY_DRUG_NAME = P_I.DRUG_NAME
    , PRIMARY = REPLACE(P_I.DRUG_NAME," + ","-",0)
    , BRAND = P_D.BRAND_NAME
    , TRADE = CONCAT
        (
            TRIM(P_D.BRAND_NAME)
            , " "
            , TRIM(REPLACE(P_D.FORM_STRENGTH, TRIM(P_I.DRUG_NAME), "", 0))
        )
    , GENERIC = P_D.FORM_STRENGTH
    , PRODUCT_PACKAGE_SIZE = P_D.PACK_SIZE
;   , PRODUCT_MANUFACTURER_CODE = P_M.MANUFACTURER_CODE
;   , SCHEDULE = P_L.DRUG_TYPE_MEAN
    , ITEM_BEG_DATE = FORMAT(P_I.BEG_EFFECTIVE_DT_TM, "DD/MMM/YYYY")
    , PRODUCT_BEG_DATE = FORMAT(P_D.BEG_EFFECTIVE_DT_TM, "DD/MMM/YYYY")

FROM
     PBS_LISTING    P_L
    , PBS_ITEM      P_I
    , PBS_DRUG      P_D

PLAN P_D
    WHERE   P_D.END_EFFECTIVE_DT_TM > (SYSDATE) ; CURRENT PRODUCTS ONLY
    ;ONLY SHOW CODES FROM THE MOST RECENT PACKAGE
    AND P_D.BEG_EFFECTIVE_DT_TM = (SELECT MAX(BEG_EFFECTIVE_DT_TM) FROM PBS_DRUG)
    ;EXCLUDE BRAND ALTERATIONS
    AND P_D.PBS_ITEM_ID NOT IN
    (
        SELECT P_D2.PBS_ITEM_ID FROM PBS_DRUG P_D2
        WHERE  P_D.PBS_ITEM_ID = P_D2.PBS_ITEM_ID
        AND P_D2.END_EFFECTIVE_DT_TM != CNVTDATETIME("31-DEC-2100")
    )
    /* UNMAPPED in the PBS_OCS_MAPPING Table */
    AND P_D.PBS_DRUG_ID NOT IN (SELECT PBS_DRUG_ID FROM PBS_OCS_MAPPING)

JOIN    P_I
    WHERE   P_I.PBS_ITEM_ID = P_D.PBS_ITEM_ID
    AND P_I.END_EFFECTIVE_DT_TM > OUTERJOIN(SYSDATE)
    ;EXCLUDE ITEM ALTERATIONS
    AND P_I.PBS_ITEM_ID NOT IN
        (
            SELECT P_I2.PBS_ITEM_ID FROM PBS_ITEM P_I2
            WHERE  P_I.PBS_ITEM_ID = P_I2.PBS_ITEM_ID
            AND P_I2.END_EFFECTIVE_DT_TM != CNVTDATETIME("31-DEC-2100")
        )

JOIN    P_L
    WHERE   P_L.PBS_LISTING_ID = P_I.PBS_LISTING_ID
    ; DON'T MAP THE PRIVATE HOSPITAL CODES ETC
    AND P_L.DRUG_TYPE_MEAN NOT IN ("DB", "HS", "IN", "PQ", "TY")
    ; Only map these "MEDICALPRACTITIONER", "NURSEPRACTITIONER", "MIDWIFE"
    AND P_L.PBS_ITEM_CODE  IN
        (
            SELECT PBS_ITEM_CODE FROM PBS_PRESCRIBER
            WHERE PRESCRIBER_TYPE_CD IN
            (
                SELECT CV.CODE_VALUE FROM CODE_VALUE CV
                WHERE CV.CODE_SET = 4386008
                ;DON'T MAP DENTAL AND OPTOMETRIST CODES
                AND CV.DISPLAY_KEY IN ("MEDICALPRACTITIONER", "NURSEPRACTITIONER", "MIDWIFE")
            )
            AND END_EFFECTIVE_DT_TM = CNVTDATETIME("31-DEC-2100")
        )

ORDER BY
    P_I.DRUG_NAME
    , P_D.BRAND_NAME
    , P_D.FORM_STRENGTH
    , 0


WITH    TIME = 10
</textarea>

        <p>
            <strong>Step 2:</strong> Click the button to copy the code above, run it in DVDev, and copy the output.
        </p>
        <button id="copyToMapCodeBtn">
            Copy PBS Items To Map Extract Code
        </button>

        <p>
            <strong>Step 3:</strong> Click the button below to load the data from your clipboard.
        </p>
        <button id="loadToMapClipboardBtn" class="hidden">
            Copy New PBS Items from clipboard
        </button>
        <p id="toMapStatus"></p>
    </div>

    <div id="settingsSection" class="section hidden">
        <h2>Part 3: Configuration</h2>
        <div class="settings-box">
            <p>Please configure the matching process before continuing.</p>
            
            <div class="setting-row">
                <div class="setting-label">Auto-Map Exact Matches:</div>
                <input type="checkbox" id="autoMapCheckbox">
                
                <div class="tooltip-container">
                    <div class="info-icon">?</div>
                    <span class="tooltip-text">
                        <strong>Auto-Map:</strong><br>
                        If enabled, the tool will automatically link items where the names are identical (100% match) without asking for confirmation.
                        <br><br>
                        Matches will be logged in the 'Auto-Match Log' on the right.
                    </span>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-label">Matching Threshold (0.0 - 1.0):</div>
                <input type="number" id="thresholdInput" value="0.7" step="0.05" min="0.1" max="1.0" style="width: 60px;">
                
                <div class="tooltip-container">
                    <div class="info-icon">?</div>
                    <span class="tooltip-text">
                        <strong>Fuzzy Match Strictness:</strong><br>
                        Controls how close a name must be to appear in the suggestions list.
                        <br><br>
                        • <strong>1.0:</strong> Exact match only.<br>
                        • <strong>0.7 (Default):</strong> Good balance.<br>
                        • <strong>0.5:</strong> Loose match (shows more options).
                    </span>
                </div>
            </div>

            <br>
            <button id="startMappingBtn" style="padding: 10px 20px; font-weight: bold;">Start Mapping Process</button>
        </div>
    </div>

    <div id="mappingSection" class="section hidden">
        <h2>Part 4: Data Mapping</h2>
        <div class="progress-bar">
            <div id="progress" class="progress"></div>
        </div>

        <div class="mapping-row">
            
            <div class="mapping-left-col">
                
                <div>
                    <p>Current PBS Item Details:</p>
                    <div class="currentItemDetailsBox">
                        <div id="currentItemDetails"></div>
                    </div>
                    <p>Row: <span id="rowNumber"></span>, Type: <b><span id="currentColumn"></span></b></p>
                    <p id="matchesHeader"></p>
                </div>

                <div>
                    <div class="nav-buttons">
                        <button id="backButton" class="disabled">Back</button>
                        <button id="nextButton">Next / Save Selections</button>
                    </div>
                    <p>List of Close Matches from our Catalog:</p>
                    <div id="matchesContainer"></div>
                </div>

            </div>

            <div id="autoMatchLogContainer">
                <strong>Auto-Match Log:</strong>
                <div id="autoMatchLog"></div>
            </div>

        </div>
    </div>

    <div id="outputSection" class="section hidden">
        <h2>Part 5: Generated Code</h2>
        <p>The CCL update script has been copied to your clipboard. You can paste it into DVdev.</p>
        <div id="outputContainer"></div>
    </div>

    <script>
        // Application State
        let appState = {
            data1: [],    // PBS Items to map
            data2: [],    // Pharmacy Catalog
            df_primaries: [],
            df_brands: [],
            df_generics: [],
            df_trades: [],
            row_number: 0,
            column_number: 0,
            columns: ['PRIMARY', 'BRAND','GENERIC', 'TRADE'],
            matches: [],
            final_matches: [], // Stores selected matches
            total_steps: 0,
            autoMapExactMatches: false,
            matchThreshold: 0.7
        };

        // DOM Elements
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const autoMatchLogContainer = document.getElementById('autoMatchLogContainer');
        const autoMatchLog = document.getElementById('autoMatchLog');
        const startMappingBtn = document.getElementById('startMappingBtn');

        // --- Function to copy from Text Area ---
        function copyFromTextArea(textAreaId) {
            const textArea = document.getElementById(textAreaId);
            if (!textArea) return;
            
            const textToCopy = textArea.value;
            
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    alert('Code copied to clipboard.');
                })
                .catch(err => {
                    alert('Failed to copy code to clipboard: ' + err);
                });
        }

        function parseData(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                return [];
            }
            const headers = lines[0].split('\t');
            return lines.slice(1).map(line => {
                const values = line.split('\t');
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header.trim()] = values[index] ? values[index].trim() : '';
                });
                return obj;
            });
        }

        function checkDataLoaded() {
            if (appState.data1.length > 0 && appState.data2.length > 0) {
                if (!validateColumns(appState.data1)) return;

                document.getElementById('pharmacyCatalogSection').classList.add('hidden');
                document.getElementById('pbsItemsSection').classList.add('hidden');
                document.getElementById('settingsSection').classList.remove('hidden');
                processData2();
            }
        }

        function validateColumns(data) {
            let requiredColumns = ['PRIMARY', 'BRAND', 'GENERIC', 'TRADE'];
            let missingColumns = requiredColumns.filter(col => !(col in data[0]));
            if (missingColumns.length > 0) {
                alert(`Missing required columns: ${missingColumns.join(', ')}`);
                return false;
            }
            return true;
        }

        function processData2() {
            appState.df_primaries = appState.data2.filter(item => item['ITEM_TYPE'] === 'PRIMARY');
            appState.df_brands = appState.data2.filter(item => item['ITEM_TYPE'] === 'BRAND');
            appState.df_generics = appState.data2.filter(item => item['ITEM_TYPE'] === 'GENERIC');
            appState.df_trades = appState.data2.filter(item => item['ITEM_TYPE'] === 'TRADE');
        }

        function applySettingsAndStart() {
            appState.autoMapExactMatches = document.getElementById('autoMapCheckbox').checked;
            
            const thresholdVal = parseFloat(document.getElementById('thresholdInput').value);
            if (!isNaN(thresholdVal) && thresholdVal >= 0 && thresholdVal <= 1) {
                appState.matchThreshold = thresholdVal;
            } else {
                alert("Please enter a valid threshold between 0.0 and 1.0");
                return;
            }

            if (appState.autoMapExactMatches) {
                document.getElementById('autoMatchLogContainer').style.display = 'flex';
            } else {
                document.getElementById('autoMatchLogContainer').style.display = 'none';
            }
            
            document.getElementById('settingsSection').classList.add('hidden');
            document.getElementById('mappingSection').classList.remove('hidden');
            
            startMapping();
        }

        startMappingBtn.addEventListener('click', applySettingsAndStart);

        function startMapping() {
            appState.row_number = 0;
            appState.column_number = 0;
            appState.final_matches = [];
            appState.total_steps = appState.data1.length * appState.columns.length;
            displayCurrentItem();
        }
        
        function jaroWinkler(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            let m = 0;
            let i, j;
            if (s1.length === 0 || s2.length === 0) return 0;
            if (s1 === s2) return 1;
            const range = (Math.floor(Math.max(s1.length, s2.length) / 2)) - 1;
            const s1Matches = new Array(s1.length);
            const s2Matches = new Array(s2.length);
            for (i = 0; i < s1.length; i++) {
                const low = (i >= range) ? i - range : 0;
                const high = (i + range <= s2.length) ? (i + range) : (s2.length - 1);
                for (j = low; j <= high; j++) {
                    if (s1Matches[i] !== true && s2Matches[j] !== true && s1[i] === s2[j]) {
                        ++m;
                        s1Matches[i] = s2Matches[j] = true;
                        break;
                    }
                }
            }
            if (m === 0) return 0;
            let k = 0;
            let numTrans = 0;
            for (i = 0; i < s1.length; i++) {
                if (s1Matches[i] === true) {
                    for (j = k; j < s2.length; j++) {
                        if (s2Matches[j] === true) {
                            k = j + 1;
                            break;
                        }
                    }
                    if (s1[i] !== s2[j]) {
                        ++numTrans;
                    }
                }
            }
            let weight = (m / s1.length + m / s2.length + (m - (numTrans / 2)) / m) / 3;
            let l = 0;
            const p = 0.1;
            if (weight > 0.7) {
                while (s1[l] === s2[l] && l < 4) {
                    ++l;
                }
                weight = weight + l * p * (1 - weight);
            }
            return weight;
        }

        function performFuzzyMatching(query, data) {
            const threshold = appState.matchThreshold;
            let results = [];
            data.forEach(item => {
                const score = jaroWinkler(query, item.NAME);
                if (score >= threshold) {
                    results.push({
                        score: score,
                        value: item.NAME,
                        data: item
                    });
                }
            });
            return results;
        }

        function updateProgressBar() {
            let currentStep = appState.row_number * appState.columns.length + appState.column_number;
            let progressPercent = (currentStep / appState.total_steps) * 100;
            document.getElementById('progress').style.width = progressPercent + '%';
        }

        function advanceIndices() {
            appState.column_number++;
            if (appState.column_number >= appState.columns.length) {
                appState.column_number = 0;
                appState.row_number++;
            }
            return appState.row_number < appState.data1.length;
        }

        // --- NEW: Go Back Logic ---
        function retreatIndices() {
            appState.column_number--;
            if (appState.column_number < 0) {
                appState.column_number = appState.columns.length - 1;
                appState.row_number--;
            }
            // Ensure we don't go below 0
            if (appState.row_number < 0) {
                appState.row_number = 0;
                appState.column_number = 0;
            }
        }

        function displayCurrentItem() {
            if (appState.row_number >= appState.data1.length) {
                generateCode();
                return;
            }

            // Enable/Disable Back Button
            if (appState.row_number === 0 && appState.column_number === 0) {
                backButton.classList.add('disabled');
            } else {
                backButton.classList.remove('disabled');
            }

            updateProgressBar();

            let currentItem = appState.data1[appState.row_number];
            let currentColumn = appState.columns[appState.column_number];
            let currentItemValue = currentItem[currentColumn]; 

            let data2_subset = [];
            if (currentColumn === 'PRIMARY') data2_subset = appState.df_primaries;
            else if (currentColumn === 'BRAND') data2_subset = appState.df_brands;
            else if (currentColumn === 'GENERIC') data2_subset = appState.df_generics;
            else if (currentColumn === 'TRADE') data2_subset = appState.df_trades;

            appState.matches = performFuzzyMatching(currentItemValue, data2_subset);

            // Logic for Auto-Map (only if we are NOT re-visiting a step)
            // We check if final_matches already has data for this step. If so, treat it as "revisiting" and skip auto-map.
            const alreadyMatched = appState.final_matches.some(m => 
                m._rowIndex === appState.row_number && m._colIndex === appState.column_number
            );

            if (appState.autoMapExactMatches && !alreadyMatched) {
                let exactMatch = appState.matches.find(m => m.score === 1);
                if (exactMatch) {
                    let combined = Object.assign({}, currentItem, exactMatch.data);
                    combined['MatchedColumn'] = currentColumn;
                    
                    // Add metadata for history tracking
                    combined['_rowIndex'] = appState.row_number;
                    combined['_colIndex'] = appState.column_number;

                    appState.final_matches.push(combined);

                    let logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.innerHTML = `Matched <strong>${currentItemValue}</strong> to <strong>${exactMatch.value}</strong> (${currentColumn})`;
                    autoMatchLog.appendChild(logEntry);
                    autoMatchLog.scrollTop = autoMatchLog.scrollHeight; 

                    if (advanceIndices()) {
                        setTimeout(displayCurrentItem, 10);
                        return;
                    } else {
                        generateCode();
                        return;
                    }
                }
            }

            document.getElementById('rowNumber').innerText = appState.row_number;
            document.getElementById('currentColumn').innerText = currentColumn;

            let currentItemDetails = document.getElementById('currentItemDetails');
            currentItemDetails.innerHTML = '';
            for (let key in currentItem) {
                currentItemDetails.innerHTML += `<strong>${key}:</strong> ${currentItem[key]}<br>`;
            }

            let matchesHeader = document.getElementById('matchesHeader');
            matchesHeader.innerHTML = `PBS Name: <strong>${currentItemValue}</strong>`;

            displayMatches();

            document.body.style.cursor = 'default';
            nextButton.classList.remove('disabled');
        }

        function displayMatches() {
            let matchesContainer = document.getElementById('matchesContainer');
            matchesContainer.innerHTML = '';

            // --- RESTORE PREVIOUSLY SELECTED CHECKBOXES ---
            // 1. Find items in final_matches that belong to current row/column
            const previouslySelected = appState.final_matches.filter(m => 
                m._rowIndex === appState.row_number && m._colIndex === appState.column_number
            );
            // 2. Create a Set of their SYNONYM_IDs for fast lookup
            const selectedIds = new Set(previouslySelected.map(m => m.MAP_SYNONYM_ID_));

            if (appState.matches.length === 0) {
                matchesContainer.innerHTML = '<p>No matches found.</p>';
                return;
            }

            appState.matches.sort((a, b) => b.score - a.score);

            appState.matches.forEach((match, index) => {
                let checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'match-' + index;
                checkbox.value = index;

                // Check it if it was in our history
                if (selectedIds.has(match.data.MAP_SYNONYM_ID_)) {
                    checkbox.checked = true;
                }

                let label = document.createElement('label');
                let scorePercentage = (match.score * 100).toFixed(0) + '%';
                let primaryField = match.data.PRIMARY ? `(PRIMARY: ${match.data.PRIMARY})` : '';

                label.htmlFor = 'match-' + index;
                label.innerHTML = `
                    <strong>${match.value}</strong> 
                    (<span style="color: green;">Score: ${scorePercentage}</span>) 
                    - ${primaryField}`;

                matchesContainer.appendChild(checkbox);
                matchesContainer.appendChild(label);
                matchesContainer.appendChild(document.createElement('hr'));
            });
        }

        function saveMatchesAndNext() {
            document.body.style.cursor = 'wait';
            nextButton.classList.add('disabled');

            // 1. Gather User Selection from UI
            let selectedMatches = [];
            appState.matches.forEach((match, index) => {
                let checkbox = document.getElementById('match-' + index);
                if (checkbox && checkbox.checked) {
                    selectedMatches.push(match);
                }
            });

            // 2. Remove ANY existing matches for this specific step (Row+Col) from final_matches.
            //    This is crucial if the user hit "Back" and is now changing their mind.
            appState.final_matches = appState.final_matches.filter(m => 
                !(m._rowIndex === appState.row_number && m._colIndex === appState.column_number)
            );

            // 3. Add the new selections
            selectedMatches.forEach(match => {
                let currentItem = appState.data1[appState.row_number];
                let currentColumn = appState.columns[appState.column_number];
                let combined = Object.assign({}, currentItem, match.data);
                
                combined['MatchedColumn'] = currentColumn;
                
                // Add Metadata to identify where this match came from
                combined['_rowIndex'] = appState.row_number;
                combined['_colIndex'] = appState.column_number;

                appState.final_matches.push(combined);
            });

            if (advanceIndices()) {
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        displayCurrentItem();
                    }, 100); // Slight delay for UI responsiveness
                });
            } else {
                generateCode();
            }
        }

        function goBack() {
            retreatIndices();
            displayCurrentItem();
        }

        document.getElementById('nextButton').addEventListener('click', saveMatchesAndNext);
        document.getElementById('backButton').addEventListener('click', goBack);

        function generateCode() {
            let output = '';
            let template = `
;________________________________________________
;  PBS mapping script for PBS_DRUG_ID: MAP_PBS_DRUG_ID_ and SYNONYM_ID: MAP_SYNONYM_ID_
; This Maps PBS NAME: !NAME! to SYNONYM: !SYNONYM!
update into pbs_ocs_mapping ocsm
set
    ocsm.beg_effective_dt_tm = cnvtdatetime(curdate, 0004)
    , ocsm.end_effective_dt_tm = cnvtdatetime("31-DEC-2100")
    /*CHANGE THE ROW BELOW MAP_PBS_DRUG_ID_*/
    , ocsm.pbs_drug_id = MAP_PBS_DRUG_ID_ 
    /*CHANGE THE ROW BELOW MAP_SYNONYM_ID_*/
    , ocsm.synonym_id = MAP_SYNONYM_ID_ 
    , ocsm.drug_synonym_id = 0 
    , ocsm.main_multum_drug_code = 0 
    , ocsm.drug_identifier = "0" 
    , ocsm.updt_dt_tm = cnvtdatetime(curdate,curtime3)
    , ocsm.updt_id = reqinfo->updt_id
    , ocsm.updt_cnt = ocsm.updt_cnt + 1
where
    ocsm.pbs_ocs_mapping_id =
    (select min(pbs_ocs_mapping_id) from pbs_ocs_mapping where end_effective_dt_tm < sysdate)
    and not exists
    (
        select 1
        from pbs_ocs_mapping
        where pbs_drug_id = MAP_PBS_DRUG_ID_
        and synonym_id = MAP_SYNONYM_ID_
        and end_effective_dt_tm > sysdate
    )
;________________________________________________
`;
            
            // SORTING: Ensure output is in order even if user jumped back and forth
            // Sort by Row Index, then by Column Index
            appState.final_matches.sort((a, b) => {
                if (a._rowIndex !== b._rowIndex) return a._rowIndex - b._rowIndex;
                return a._colIndex - b._colIndex;
            });

            appState.final_matches.forEach(match => {
                let code = template;
                let pbsId = match['MAP_PBS_DRUG_ID_'] || '0';
                let synonymId = match['MAP_SYNONYM_ID_'] || '0';
                
                code = code.replace(/MAP_PBS_DRUG_ID_/g, pbsId);
                code = code.replace(/MAP_SYNONYM_ID_/g, synonymId);
                
                // UPDATED LOGIC:
                let matchedColumnName = match['MatchedColumn'];
                let pbsName = match[matchedColumnName] || 'Unknown';
                let synonymName = match['NAME'] || 'Unknown';

                code = code.replace('!NAME!', pbsName); 
                code = code.replace('!SYNONYM!', synonymName);

                output += code + '\n\n\n';
            });

            let outputContainer = document.getElementById('outputContainer');
            outputContainer.textContent = output;

            navigator.clipboard.writeText(output).then(function() {
                alert('Mapping Complete! Code copied to clipboard');
            }, function(err) {
                console.error('Could not copy text: ', err);
            });

            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('outputSection').classList.remove('hidden');
            document.body.style.cursor = 'default';
        }

        const copyPharmacyCodeBtn = document.getElementById('copyPharmacyCodeBtn');
        const loadPharmacyClipboardBtn = document.getElementById('loadPharmacyClipboardBtn');
        const pharmacyStatus = document.getElementById('pharmacyStatus');

        copyPharmacyCodeBtn.addEventListener('click', () => {
            copyFromTextArea("pharmacyCatalogCCL");
            loadPharmacyClipboardBtn.classList.remove('hidden');
        });

        loadPharmacyClipboardBtn.addEventListener('click', () => {
            navigator.clipboard.readText()
                .then(clipboardText => {
                    let data = parseData(clipboardText);
                    if (data.length > 0) {
                        pharmacyStatus.textContent = 'Pharmacy Catalog data loaded successfully.';
                        appState.data2 = data;
                        alert("The data has been loaded into this tool.");
                        document.getElementById('pharmacyCatalogSection').classList.add('hidden');
                        document.getElementById('pbsItemsSection').classList.remove('hidden');
                    } else {
                        pharmacyStatus.textContent = 'No data found or failed to parse pharmacy catalog data.';
                    }
                })
                .catch(err => {
                    pharmacyStatus.textContent = 'Failed to read clipboard contents: ' + err;
                });
        });

        const copyToMapCodeBtn = document.getElementById('copyToMapCodeBtn');
        const loadToMapClipboardBtn = document.getElementById('loadToMapClipboardBtn');
        const toMapStatus = document.getElementById('toMapStatus');

        copyToMapCodeBtn.addEventListener('click', () => {
            copyFromTextArea("pbsItemsCCL");
            loadToMapClipboardBtn.classList.remove('hidden');
        });

        loadToMapClipboardBtn.addEventListener('click', () => {
            navigator.clipboard.readText()
                .then(clipboardText => {
                    let data = parseData(clipboardText);
                    if (data.length > 0) {
                        toMapStatus.textContent = 'PBS Items to Map data loaded successfully.';
                        appState.data1 = data;
                        alert("The data has been loaded into this tool.");
                        checkDataLoaded();
                    } else {
                        toMapStatus.textContent = 'No data found or failed to parse PBS items to map.';
                    }
                })
                .catch(err => {
                    toMapStatus.textContent = 'Failed to read clipboard contents: ' + err;
                });
        });
    </script>
</body>
</html>