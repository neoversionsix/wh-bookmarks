<!DOCTYPE html>
<html>
<head>
    <title>PBS Mapping Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .section {
            margin-bottom: 40px;
        }
        #matchesContainer {
            max-height: 465px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #outputContainer {
            white-space: pre-wrap;
            background-color: #000;
            color: #fff;
            padding: 10px;
        }
        .hidden {
            display: none;
        }
        .progress-bar {
            width: 100%;
            background-color: lightgray;
            height: 20px;
            margin-bottom: 10px;
        }
        .progress {
            height: 100%;
            background-color: blue;
            width: 0%;
        }
        .currentItemDetailsBox {
            background-color: lightgrey;
            color: black;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* --- LAYOUT FOR SPLIT VIEW --- */
        .mapping-row {
            display: flex;
            gap: 20px;
            align-items: flex-start; 
        }
        
        .mapping-left-col {
            flex: 1; /* Expands to fill space */
            min-width: 0; 
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between details and matches list */
        }

        /* Styles for the Auto-Match Log */
        #autoMatchLogContainer {
            /* Layout specific */
            width: 350px; 
            flex-shrink: 0; 
            display: none; /* Hidden by default, toggled by JS */
            
            /* Visuals */
            border: 1px solid #90cdf4;
            background-color: #ebf8ff;
            padding: 10px;
            border-radius: 5px;
            
            /* Height settings */
            display: flex;
            flex-direction: column;
        }
        
        #autoMatchLog {
            /* TALLER HEIGHT as requested */
            height: 750px; 
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            color: #2c5282;
            background-color: white; 
            border: 1px solid #bee3f8;
            padding: 5px;
            margin-top: 5px;
        }
        .log-entry {
            border-bottom: 1px solid #bee3f8;
            padding: 4px 0;
        }
        
        /* Styles for Settings Section */
        .settings-box {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 5px;
            background-color: #f9f9f9;
            max-width: 600px;
        }
        .setting-row {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            position: relative;
        }
        .setting-label {
            font-weight: bold;
            margin-right: 10px;
            min-width: 200px;
        }
        
        /* --- TOOLTIP STYLES --- */
        .tooltip-container {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }

        .info-icon {
            background-color: #e7f1ff;
            color: #0056b3;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            border: 1px solid #b3d7ff;
        }

        .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 10px;
            font-size: 0.85em;
            font-weight: normal;
            line-height: 1.4;
            position: absolute;
            z-index: 100;
            bottom: 135%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0px 4px 8px rgba(0,0,0,0.3);
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>

    <!-- Heading Removed as requested -->

    <!-- PART 1: Pharmacy Catalog -->
    <div id="pharmacyCatalogSection" class="section">
        <h2>Part 1: Pharmacy Catalog</h2>
        <p>
            Click the button below to copy the CCL extract code for the Pharmacy Catalog.
            After copying the code, run it in DVDev and then copy the output from DVDev to your clipboard (ctrl-c).
        </p>
        <button id="copyPharmacyCodeBtn">
            Copy Pharmacy Catalog CCL Extract Code
        </button>

        <p>
            Click the button below to load the Pharmacy Catalog data from the clipboard.
        </p>
        <button id="loadPharmacyClipboardBtn" class="hidden">
            Copy Pharmacy Catalog from clipboard
        </button>
        <p id="pharmacyStatus"></p>
    </div>

    <!-- PART 2: PBS Items to Map (Initially hidden) -->
    <div id="pbsItemsSection" class="section hidden">
        <h2>Part 2: PBS Items to Map</h2>
        <p>
            Click the button below to copy the CCL extract code.
            After copying the code, run it in DVDev and then copy the output from DVDev to your clipboard (ctrl-c).
        </p>
        <button id="copyToMapCodeBtn">
            Copy PBS Items To Map Extract Code
        </button>

        <p>
            Click the button below to load the PBS Items to Map data from the clipboard.
        </p>
        <button id="loadToMapClipboardBtn" class="hidden">
            Copy New PBS Items from clipboard
        </button>
        <p id="toMapStatus"></p>
    </div>

    <!-- PART 3: Settings -->
    <div id="settingsSection" class="section hidden">
        <h2>Part 3: Configuration</h2>
        <div class="settings-box">
            <p>Please configure the matching process before continuing.</p>
            
            <!-- Auto Map Setting -->
            <div class="setting-row">
                <div class="setting-label">Auto-Map Exact Matches:</div>
                <input type="checkbox" id="autoMapCheckbox">
                
                <div class="tooltip-container">
                    <div class="info-icon">?</div>
                    <span class="tooltip-text">
                        <strong>Auto-Map:</strong><br>
                        If enabled, the tool will automatically link items where the names are identical (100% match) without asking for confirmation.
                        <br><br>
                        Matches will be logged in the 'Auto-Match Log' on the right.
                    </span>
                </div>
            </div>

            <!-- Threshold Setting -->
            <div class="setting-row">
                <div class="setting-label">Matching Threshold (0.0 - 1.0):</div>
                <input type="number" id="thresholdInput" value="0.7" step="0.05" min="0.1" max="1.0" style="width: 60px;">
                
                <div class="tooltip-container">
                    <div class="info-icon">?</div>
                    <span class="tooltip-text">
                        <strong>Fuzzy Match Strictness:</strong><br>
                        Controls how close a name must be to appear in the suggestions list.
                        <br><br>
                        • <strong>1.0:</strong> Exact match only.<br>
                        • <strong>0.7 (Default):</strong> Good balance.<br>
                        • <strong>0.5:</strong> Loose match (shows more options).
                    </span>
                </div>
            </div>

            <br>
            <button id="startMappingBtn" style="padding: 10px 20px; font-weight: bold;">Start Mapping Process</button>
        </div>
    </div>

    <!-- PART 4: Data Mapping -->
    <div id="mappingSection" class="section hidden">
        <h2>Part 4: Data Mapping</h2>
        <div class="progress-bar">
            <div id="progress" class="progress"></div>
        </div>

        <!-- Flex Container for Split Layout -->
        <div class="mapping-row">
            
            <!-- LEFT COLUMN: Item Details AND Matches List -->
            <div class="mapping-left-col">
                
                <!-- Item Details Section -->
                <div>
                    <p>Current PBS Item Details:</p>
                    <div class="currentItemDetailsBox">
                        <div id="currentItemDetails"></div>
                    </div>
                    <p>Row: <span id="rowNumber"></span>, Type: <b><span id="currentColumn"></span></b></p>
                    <p id="matchesHeader"></p>
                </div>

                <!-- Matches Section (Now inside Left Column) -->
                <div>
                    <button id="nextButton">Next / Save Selections</button>
                    <p>List of Close Matches from our Catalog:</p>
                    <div id="matchesContainer"></div>
                </div>

            </div>

            <!-- RIGHT COLUMN: Auto-Match Log (Hidden by default) -->
            <div id="autoMatchLogContainer">
                <strong>Auto-Match Log:</strong>
                <div id="autoMatchLog"></div>
            </div>

        </div>
    </div>

    <!-- PART 5: Generated Code -->
    <div id="outputSection" class="section hidden">
        <h2>Part 5: Generated Code</h2>
        <p>The CCL update script has been copied to your clipboard. You can paste it into DVdev.</p>
        <div id="outputContainer"></div>
    </div>

    <script>
        // Application State
        let appState = {
            data1: [],    // PBS Items to map
            data2: [],    // Pharmacy Catalog
            df_primaries: [],
            df_brands: [],
            df_generics: [],
            df_trades: [],
            row_number: 0,
            column_number: 0,
            columns: ['PRIMARY', 'BRAND','GENERIC', 'TRADE'],
            matches: [],
            final_matches: [],
            total_steps: 0,
            autoMapExactMatches: false,
            matchThreshold: 0.7
        };

        // DOM Elements
        const nextButton = document.getElementById('nextButton');
        const autoMatchLogContainer = document.getElementById('autoMatchLogContainer');
        const autoMatchLog = document.getElementById('autoMatchLog');
        const startMappingBtn = document.getElementById('startMappingBtn');

        function copyCode(url) {
            fetch(url)
                .then(response => response.text())
                .then(text => {
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            alert('Code copied to clipboard.');
                        })
                        .catch(err => {
                            alert('Failed to copy code to clipboard: ' + err);
                        });
                })
                .catch(err => {
                    alert('Failed to fetch code: ' + err);
                });
        }

        function parseData(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                return [];
            }
            const headers = lines[0].split('\t');
            return lines.slice(1).map(line => {
                const values = line.split('\t');
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header.trim()] = values[index] ? values[index].trim() : '';
                });
                return obj;
            });
        }

        function checkDataLoaded() {
            if (appState.data1.length > 0 && appState.data2.length > 0) {
                if (!validateColumns(appState.data1)) return;

                document.getElementById('pharmacyCatalogSection').classList.add('hidden');
                document.getElementById('pbsItemsSection').classList.add('hidden');
                document.getElementById('settingsSection').classList.remove('hidden');
                processData2();
            }
        }

        function validateColumns(data) {
            let requiredColumns = ['PRIMARY', 'BRAND', 'GENERIC', 'TRADE'];
            let missingColumns = requiredColumns.filter(col => !(col in data[0]));
            if (missingColumns.length > 0) {
                alert(`Missing required columns: ${missingColumns.join(', ')}`);
                return false;
            }
            return true;
        }

        function processData2() {
            appState.df_primaries = appState.data2.filter(item => item['ITEM_TYPE'] === 'PRIMARY');
            appState.df_brands = appState.data2.filter(item => item['ITEM_TYPE'] === 'BRAND');
            appState.df_generics = appState.data2.filter(item => item['ITEM_TYPE'] === 'GENERIC');
            appState.df_trades = appState.data2.filter(item => item['ITEM_TYPE'] === 'TRADE');
        }

        function applySettingsAndStart() {
            appState.autoMapExactMatches = document.getElementById('autoMapCheckbox').checked;
            
            const thresholdVal = parseFloat(document.getElementById('thresholdInput').value);
            if (!isNaN(thresholdVal) && thresholdVal >= 0 && thresholdVal <= 1) {
                appState.matchThreshold = thresholdVal;
            } else {
                alert("Please enter a valid threshold between 0.0 and 1.0");
                return;
            }

            // Show the log container ONLY if auto-map is checked
            // Added flex display to ensure layout holds
            if (appState.autoMapExactMatches) {
                document.getElementById('autoMatchLogContainer').style.display = 'flex';
            } else {
                document.getElementById('autoMatchLogContainer').style.display = 'none';
            }
            
            document.getElementById('settingsSection').classList.add('hidden');
            document.getElementById('mappingSection').classList.remove('hidden');
            
            startMapping();
        }

        startMappingBtn.addEventListener('click', applySettingsAndStart);

        function startMapping() {
            appState.row_number = 0;
            appState.column_number = 0;
            appState.final_matches = [];
            appState.total_steps = appState.data1.length * appState.columns.length;
            displayCurrentItem();
        }
        
        function jaroWinkler(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            let m = 0;
            let i, j;
            if (s1.length === 0 || s2.length === 0) return 0;
            if (s1 === s2) return 1;
            const range = (Math.floor(Math.max(s1.length, s2.length) / 2)) - 1;
            const s1Matches = new Array(s1.length);
            const s2Matches = new Array(s2.length);
            for (i = 0; i < s1.length; i++) {
                const low = (i >= range) ? i - range : 0;
                const high = (i + range <= s2.length) ? (i + range) : (s2.length - 1);
                for (j = low; j <= high; j++) {
                    if (s1Matches[i] !== true && s2Matches[j] !== true && s1[i] === s2[j]) {
                        ++m;
                        s1Matches[i] = s2Matches[j] = true;
                        break;
                    }
                }
            }
            if (m === 0) return 0;
            let k = 0;
            let numTrans = 0;
            for (i = 0; i < s1.length; i++) {
                if (s1Matches[i] === true) {
                    for (j = k; j < s2.length; j++) {
                        if (s2Matches[j] === true) {
                            k = j + 1;
                            break;
                        }
                    }
                    if (s1[i] !== s2[j]) {
                        ++numTrans;
                    }
                }
            }
            let weight = (m / s1.length + m / s2.length + (m - (numTrans / 2)) / m) / 3;
            let l = 0;
            const p = 0.1;
            if (weight > 0.7) {
                while (s1[l] === s2[l] && l < 4) {
                    ++l;
                }
                weight = weight + l * p * (1 - weight);
            }
            return weight;
        }

        function performFuzzyMatching(query, data) {
            const threshold = appState.matchThreshold;
            let results = [];
            data.forEach(item => {
                const score = jaroWinkler(query, item.NAME);
                if (score >= threshold) {
                    results.push({
                        score: score,
                        value: item.NAME,
                        data: item
                    });
                }
            });
            return results;
        }

        function updateProgressBar() {
            let currentStep = appState.row_number * appState.columns.length + appState.column_number;
            let progressPercent = (currentStep / appState.total_steps) * 100;
            document.getElementById('progress').style.width = progressPercent + '%';
        }

        function advanceIndices() {
            appState.column_number++;
            if (appState.column_number >= appState.columns.length) {
                appState.column_number = 0;
                appState.row_number++;
            }
            return appState.row_number < appState.data1.length;
        }

        function displayCurrentItem() {
            if (appState.row_number >= appState.data1.length) {
                generateCode();
                return;
            }

            updateProgressBar();

            let currentItem = appState.data1[appState.row_number];
            let currentColumn = appState.columns[appState.column_number];
            let currentItemValue = currentItem[currentColumn]; 

            let data2_subset = [];
            if (currentColumn === 'PRIMARY') data2_subset = appState.df_primaries;
            else if (currentColumn === 'BRAND') data2_subset = appState.df_brands;
            else if (currentColumn === 'GENERIC') data2_subset = appState.df_generics;
            else if (currentColumn === 'TRADE') data2_subset = appState.df_trades;

            appState.matches = performFuzzyMatching(currentItemValue, data2_subset);

            if (appState.autoMapExactMatches) {
                let exactMatch = appState.matches.find(m => m.score === 1);
                if (exactMatch) {
                    let combined = Object.assign({}, currentItem, exactMatch.data);
                    combined['MatchedColumn'] = currentColumn;
                    appState.final_matches.push(combined);

                    let logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.innerHTML = `Matched <strong>${currentItemValue}</strong> to <strong>${exactMatch.value}</strong> (${currentColumn})`;
                    autoMatchLog.appendChild(logEntry);
                    autoMatchLog.scrollTop = autoMatchLog.scrollHeight; 

                    if (advanceIndices()) {
                        setTimeout(displayCurrentItem, 10);
                        return;
                    } else {
                        generateCode();
                        return;
                    }
                }
            }

            document.getElementById('rowNumber').innerText = appState.row_number;
            document.getElementById('currentColumn').innerText = currentColumn;

            let currentItemDetails = document.getElementById('currentItemDetails');
            currentItemDetails.innerHTML = '';
            for (let key in currentItem) {
                currentItemDetails.innerHTML += `<strong>${key}:</strong> ${currentItem[key]}<br>`;
            }

            let matchesHeader = document.getElementById('matchesHeader');
            matchesHeader.innerHTML = `PBS Name: <strong>${currentItemValue}</strong>`;

            displayMatches();

            document.body.style.cursor = 'default';
            nextButton.classList.remove('disabled');
        }

        function displayMatches() {
            let matchesContainer = document.getElementById('matchesContainer');
            matchesContainer.innerHTML = '';

            if (appState.matches.length === 0) {
                matchesContainer.innerHTML = '<p>No matches found.</p>';
                return;
            }

            appState.matches.sort((a, b) => b.score - a.score);

            appState.matches.forEach((match, index) => {
                let checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'match-' + index;
                checkbox.value = index;

                let label = document.createElement('label');
                let scorePercentage = (match.score * 100).toFixed(0) + '%';
                let primaryField = match.data.PRIMARY ? `(PRIMARY: ${match.data.PRIMARY})` : '';

                label.htmlFor = 'match-' + index;
                label.innerHTML = `
                    <strong>${match.value}</strong> 
                    (<span style="color: green;">Score: ${scorePercentage}</span>) 
                    - ${primaryField}`;

                matchesContainer.appendChild(checkbox);
                matchesContainer.appendChild(label);
                matchesContainer.appendChild(document.createElement('hr'));
            });
        }

        function saveMatchesAndNext() {
            document.body.style.cursor = 'wait';
            nextButton.classList.add('disabled');

            let selectedMatches = [];
            appState.matches.forEach((match, index) => {
                let checkbox = document.getElementById('match-' + index);
                if (checkbox && checkbox.checked) {
                    selectedMatches.push(match);
                }
            });

            selectedMatches.forEach(match => {
                let currentItem = appState.data1[appState.row_number];
                let currentColumn = appState.columns[appState.column_number];
                let combined = Object.assign({}, currentItem, match.data);
                combined['MatchedColumn'] = currentColumn;
                appState.final_matches.push(combined);
            });

            if (advanceIndices()) {
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        displayCurrentItem();
                    }, 500);
                });
            } else {
                generateCode();
            }
        }

        document.getElementById('nextButton').addEventListener('click', saveMatchesAndNext);

        function generateCode() {
            let output = '';
            let template = `
;________________________________________________
;  PBS mapping script for PBS_DRUG_ID: MAP_PBS_DRUG_ID_ and SYNONYM_ID: MAP_SYNONYM_ID_
; This Maps PBS NAME: !NAME! to SYNONYM: !SYNONYM!
update into pbs_ocs_mapping ocsm
set
    ocsm.beg_effective_dt_tm = cnvtdatetime(curdate, 0004)
    , ocsm.end_effective_dt_tm = cnvtdatetime("31-DEC-2100")
    /*CHANGE THE ROW BELOW MAP_PBS_DRUG_ID_*/
    , ocsm.pbs_drug_id = MAP_PBS_DRUG_ID_ 
    /*CHANGE THE ROW BELOW MAP_SYNONYM_ID_*/
    , ocsm.synonym_id = MAP_SYNONYM_ID_ 
    , ocsm.drug_synonym_id = 0 
    , ocsm.main_multum_drug_code = 0 
    , ocsm.drug_identifier = "0" 
    , ocsm.updt_dt_tm = cnvtdatetime(curdate,curtime3)
    , ocsm.updt_id = reqinfo->updt_id
    , ocsm.updt_cnt = ocsm.updt_cnt + 1
where
    ocsm.pbs_ocs_mapping_id =
    (select min(pbs_ocs_mapping_id) from pbs_ocs_mapping where end_effective_dt_tm < sysdate)
    and not exists
    (
        select 1
        from pbs_ocs_mapping
        where pbs_drug_id = MAP_PBS_DRUG_ID_
        and synonym_id = MAP_SYNONYM_ID_
        and end_effective_dt_tm > sysdate
    )
;________________________________________________
`;

            appState.final_matches.forEach(match => {
                let code = template;
                let pbsId = match['MAP_PBS_DRUG_ID_'] || '0';
                let synonymId = match['MAP_SYNONYM_ID_'] || '0';
                
                code = code.replace(/MAP_PBS_DRUG_ID_/g, pbsId);
                code = code.replace(/MAP_SYNONYM_ID_/g, synonymId);
                code = code.replace('!NAME!', match['NAME'] || 'Unknown'); 
                code = code.replace('!SYNONYM!', match['SYNONYM'] || 'Unknown');

                output += code + '\n\n\n';
            });

            let outputContainer = document.getElementById('outputContainer');
            outputContainer.textContent = output;

            navigator.clipboard.writeText(output).then(function() {
                alert('Mapping Complete! Code copied to clipboard');
            }, function(err) {
                console.error('Could not copy text: ', err);
            });

            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('outputSection').classList.remove('hidden');
            document.body.style.cursor = 'default';
        }

        const copyPharmacyCodeBtn = document.getElementById('copyPharmacyCodeBtn');
        const loadPharmacyClipboardBtn = document.getElementById('loadPharmacyClipboardBtn');
        const pharmacyStatus = document.getElementById('pharmacyStatus');

        copyPharmacyCodeBtn.addEventListener('click', () => {
            copyCode("https://raw.githubusercontent.com/neoversionsix/custom-ccl-jobs/refs/heads/main/PBS/PBS%20Pharmacy%20Catalogue%20-%20Possible%20Items%20to%20Map%20to%20(All%20types).ccl");
            loadPharmacyClipboardBtn.classList.remove('hidden');
        });

        loadPharmacyClipboardBtn.addEventListener('click', () => {
            navigator.clipboard.readText()
                .then(clipboardText => {
                    let data = parseData(clipboardText);
                    if (data.length > 0) {
                        pharmacyStatus.textContent = 'Pharmacy Catalog data loaded successfully.';
                        appState.data2 = data;
                        alert("The data has been loaded into this tool.");
                        document.getElementById('pharmacyCatalogSection').classList.add('hidden');
                        document.getElementById('pbsItemsSection').classList.remove('hidden');
                    } else {
                        pharmacyStatus.textContent = 'No data found or failed to parse pharmacy catalog data.';
                    }
                })
                .catch(err => {
                    pharmacyStatus.textContent = 'Failed to read clipboard contents: ' + err;
                });
        });

        const copyToMapCodeBtn = document.getElementById('copyToMapCodeBtn');
        const loadToMapClipboardBtn = document.getElementById('loadToMapClipboardBtn');
        const toMapStatus = document.getElementById('toMapStatus');

        copyToMapCodeBtn.addEventListener('click', () => {
            copyCode("https://raw.githubusercontent.com/neoversionsix/custom-ccl-jobs/refs/heads/main/PBS/PBS%20Last%20Installed%20Package%20Items%20to%20Map%20-%20Without%20any%20Mappings%20-%20Distinct%20Mappings%20for%20Package.ccl");
            loadToMapClipboardBtn.classList.remove('hidden');
        });

        loadToMapClipboardBtn.addEventListener('click', () => {
            navigator.clipboard.readText()
                .then(clipboardText => {
                    let data = parseData(clipboardText);
                    if (data.length > 0) {
                        toMapStatus.textContent = 'PBS Items to Map data loaded successfully.';
                        appState.data1 = data;
                        alert("The data has been loaded into this tool.");
                        checkDataLoaded();
                    } else {
                        toMapStatus.textContent = 'No data found or failed to parse PBS items to map.';
                    }
                })
                .catch(err => {
                    toMapStatus.textContent = 'Failed to read clipboard contents: ' + err;
                });
        });
    </script>
</body>
</html>